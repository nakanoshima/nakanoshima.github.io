<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>MOGU MOGU MOGURA</title>
    <style>
      body {
        text-align: center;
        font-family: monospace; /* Use monospace for ASCII art consistency */
        margin: 20px;
        background-color: #f5deb3;
      }
      pre.title {
        margin: 0;
        font-size: 16px;
        line-height: 1.1;
        color: orange;
      }
      #info {
        font-family: "Courier New", Courier, monospace;
        font-size: 20px;
        margin: 10px 0;
      }
      canvas {
        border: 1px solid #333;
        background: #5a3d20; /* Darker base colour for hidden cells */
      }
      button {
        margin-top: 20px;
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <!-- ASCII art title -->
    <pre class="title">
___  ___             ___  ___             ___  ___                            
|  \/  |             |  \/  |             |  \/  |                            
| .  . | ___   __ _  | .  . | ___   __ _  | .  . | ___   __ _ _   _ _ __ __ _ 
| |\/| |/ _ \ / _` | | |\/| |/ _ \ / _` | | |\/| |/ _ \ / _` | | | | '__/ _` |
| |  | | (_) | (_| | | |  | | (_) | (_| | | |  | | (_) | (_| | |_| | | | (_| |
\_|  |_/\___/ \__, | \_|  |_/\___/ \__, | \_|  |_/\___/ \__, |\__,_|_|  \__,_|
               __/ |                __/ |                __/ |                
              |___/                |___/                |___/                  
    </pre>
    <div id="info">
      <span id="level">Level: 1</span> | <span id="score">Score: 0</span> |
      <span id="timer">Time: 5</span>
    </div>
    <canvas id="gameCanvas" width="800" height="840" tabindex="0"></canvas>
    <p id="message"></p>
    <button id="newGame">New Game</button>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const timerEl = document.getElementById("timer");
      const levelEl = document.getElementById("level");
      const messageEl = document.getElementById("message");
      const newGameBtn = document.getElementById("newGame");

      const cellSize = 40;
      const gridOffsetY = 40; // Height of the grass band.
      const rows = 20;
      const cols = 20;

      let level = 1;
      let numTreasures = Math.pow(2, level - 1); // Level 1: 1 onigiri.
      let grid = []; // 2D array for cells.
      let mole = { row: 0, col: 0 };
      let badger = { row: 0, col: 0 };
      let score = 0;
      let treasuresLeft = numTreasures;
      let gameActive = true;
      let timeLeft = 60;
      let timerInterval = null;

      // Turn counter.
      let currentTurn = 1;

      // For drawing a fixed molehill.
      let startingMoleCol = 0;

      // Offscreen canvas for unrevealed ground texture.
      const groundTextureCanvas = document.createElement("canvas");
      groundTextureCanvas.width = cellSize;
      groundTextureCanvas.height = cellSize;
      const gtx = groundTextureCanvas.getContext("2d");
      gtx.fillStyle = "#5a3d20";
      gtx.fillRect(0, 0, cellSize, cellSize);
      for (let i = 0; i < 50; i++) {
        const x = Math.random() * cellSize;
        const y = Math.random() * cellSize;
        gtx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1})`;
        gtx.beginPath();
        gtx.arc(x, y, Math.random() * 1.5, 0, 2 * Math.PI);
        gtx.fill();
      }
      const groundPattern = ctx.createPattern(groundTextureCanvas, "repeat");

      // Offscreen canvas for tunnel (revealed cells) texture.
      const tunnelTextureCanvas = document.createElement("canvas");
      tunnelTextureCanvas.width = cellSize;
      tunnelTextureCanvas.height = cellSize;
      const ttx = tunnelTextureCanvas.getContext("2d");
      const grad = ttx.createLinearGradient(0, 0, cellSize, cellSize);
      grad.addColorStop(0, "#8B4513");
      grad.addColorStop(1, "#5D2E0E");
      ttx.fillStyle = grad;
      ttx.fillRect(0, 0, cellSize, cellSize);
      for (let i = 0; i < 30; i++) {
        const x = Math.random() * cellSize;
        const y = Math.random() * cellSize;
        ttx.fillStyle = `rgba(0,0,0,${Math.random() * 0.15})`;
        ttx.fillRect(x, y, 2, 2);
      }
      const tunnelPattern = ctx.createPattern(tunnelTextureCanvas, "repeat");

      // Each cell: { type: 'dirt' | 'treasure', revealed: Boolean, revealedTime?: number }
      function initGrid() {
        grid = [];
        for (let r = 0; r < rows; r++) {
          const rowArray = [];
          for (let c = 0; c < cols; c++) {
            rowArray.push({ type: "dirt", revealed: false });
          }
          grid.push(rowArray);
        }
        // Place treasures randomly (avoid mole's starting cell).
        let placedTreasures = 0;
        while (placedTreasures < numTreasures) {
          const r = Math.floor(Math.random() * rows);
          const c = Math.floor(Math.random() * cols);
          if ((r === mole.row && c === mole.col) || grid[r][c].type !== "dirt")
            continue;
          grid[r][c].type = "treasure";
          placedTreasures++;
        }
      }

      // Initialise mole at a random column on the top row.
      function initMole() {
        const col = Math.floor(Math.random() * cols);
        mole = { row: 0, col: col };
        startingMoleCol = col; // Fixed molehill position.
      }

      // Initialise badger at a random column on the bottom row.
      function initBadger() {
        let col = Math.floor(Math.random() * cols);
        if (grid[rows - 1][col].type !== "dirt") {
          for (let offset = 0; offset < cols; offset++) {
            let left = col - offset;
            let right = col + offset;
            if (left >= 0 && grid[rows - 1][left].type === "dirt") {
              col = left;
              break;
            } else if (right < cols && grid[rows - 1][right].type === "dirt") {
              col = right;
              break;
            }
          }
        }
        badger = { row: rows - 1, col: col };
      }

      // Draw the molehill above the mole's starting position.
      function drawMoleHill() {
        const hillX = startingMoleCol * cellSize + cellSize / 2;
        const hillY = gridOffsetY / 2;
        ctx.fillStyle = "#8B4513";
        ctx.beginPath();
        ctx.ellipse(
          hillX,
          hillY,
          cellSize / 2,
          cellSize / 4,
          0,
          0,
          2 * Math.PI
        );
        ctx.fill();
        ctx.strokeStyle = "rgba(0, 0, 0, 0.3)";
        ctx.stroke();
      }

      // Initialize or reset the game.
      function initGame() {
        levelEl.textContent = "Level: " + level;
        numTreasures = Math.pow(2, level - 1);
        treasuresLeft = numTreasures;
        timeLeft = 60;
        gameActive = true;
        score = 0;
        currentTurn = 1; // Reset turn counter.
        scoreEl.textContent = "Score: " + score;
        timerEl.textContent = "Time: " + timeLeft;
        messageEl.textContent =
          "Find all the onigiri (treasures) without getting caught by the badger!";

        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
          timeLeft--;
          timerEl.textContent = "Time: " + timeLeft;
          if (timeLeft <= 0) {
            clearInterval(timerInterval);
            gameActive = false;
            messageEl.textContent = "Time's up! Game Over!";
          }
          update();
        }, 1000);

        initMole();
        initGrid();
        initBadger();

        // Reveal the mole's starting cell.
        grid[mole.row][mole.col].revealed = true;
        // Set starting cell's revealedTime to 0 so that a new move gets a fresh turn.
        grid[mole.row][mole.col].revealedTime = 0;
        update();
        canvas.focus();
      }

      // Draw the grassy area at the top.
      function drawGrass() {
        ctx.fillStyle = "green";
        ctx.fillRect(0, 0, canvas.width, gridOffsetY);
        ctx.strokeStyle = "darkgreen";
        for (let i = 0; i < canvas.width; i += 10) {
          const bladeHeight = Math.random() * 10 + 10;
          ctx.beginPath();
          ctx.moveTo(i, gridOffsetY);
          ctx.lineTo(i + 5, gridOffsetY - bladeHeight);
          ctx.stroke();
        }
        drawMoleHill();
      }

      // Draw the grid.
      function drawGrid() {
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const x = c * cellSize;
            const y = gridOffsetY + r * cellSize;
            if (grid[r][c].type === "treasure") {
              ctx.fillStyle = grid[r][c].revealed
                ? tunnelPattern
                : groundPattern;
              ctx.fillRect(x, y, cellSize, cellSize);
              ctx.strokeStyle = grid[r][c].revealed ? "#111" : "#333";
              ctx.strokeRect(x, y, cellSize, cellSize);
              ctx.font = "28px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText("🍙", x + cellSize / 2, y + cellSize / 2);
            } else if (grid[r][c].revealed) {
              ctx.fillStyle = tunnelPattern;
              ctx.fillRect(x, y, cellSize, cellSize);
              ctx.strokeStyle = "#111";
              ctx.strokeRect(x, y, cellSize, cellSize);
            } else {
              ctx.fillStyle = groundPattern;
              ctx.fillRect(x, y, cellSize, cellSize);
              ctx.strokeStyle = "#333";
              ctx.strokeRect(x, y, cellSize, cellSize);
            }
          }
        }
      }

      // Draw the mole.
      function drawMole() {
        const x = mole.col * cellSize;
        const y = gridOffsetY + mole.row * cellSize;
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(
          x + cellSize / 2,
          y + cellSize / 2,
          cellSize / 3,
          0,
          2 * Math.PI
        );
        ctx.fill();
      }

      // Draw the badger using an emoji.
      function drawBadger() {
        const x = badger.col * cellSize;
        const y = gridOffsetY + badger.row * cellSize;
        ctx.font = "28px 'Segoe UI Emoji', 'Apple Color Emoji', Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("🦡", x + cellSize / 2, y + cellSize / 2);
      }

      // Update the canvas.
      function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrass();
        drawGrid();
        drawMole();
        drawBadger();
        scoreEl.textContent = "Score: " + score;
      }

      // Move the badger one cell toward the mole.
      // The badger is allowed to enter an unrevealed cell,
      // or a cell revealed in this turn (i.e. freshly dug),
      // and will catch the mole if it moves into such a cell.
      function moveBadger(thisTurn) {
        // First, check adjacent cells for the mole's cell that was dug this turn.
        for (let [dr, dc] of [
          [-1, 0],
          [0, -1],
          [0, 1],
          [1, 0],
        ]) {
          let newRow = badger.row + dr;
          let newCol = badger.col + dc;
          if (newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols)
            continue;
          if (
            newRow === mole.row &&
            newCol === mole.col &&
            grid[newRow][newCol].revealedTime === thisTurn
          ) {
            badger.row = newRow;
            badger.col = newCol;
            gameActive = false;
            clearInterval(timerInterval);
            messageEl.textContent = "Game Over: The Badger caught you!";
            return;
          }
        }
        // Otherwise, choose the best adjacent move.
        let bestMove = null;
        let bestDistance = Infinity;
        for (let [dr, dc] of [
          [-1, 0],
          [0, -1],
          [0, 1],
          [1, 0],
        ]) {
          let newRow = badger.row + dr;
          let newCol = badger.col + dc;
          if (newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols)
            continue;
          // Allow movement into an unrevealed cell.
          if (!grid[newRow][newCol].revealed) {
            let distance = Math.hypot(mole.row - newRow, mole.col - newCol);
            if (distance < bestDistance) {
              bestDistance = distance;
              bestMove = { row: newRow, col: newCol };
            }
          }
          // Or into a cell revealed in this turn.
          else if (grid[newRow][newCol].revealedTime === thisTurn) {
            let distance = Math.hypot(mole.row - newRow, mole.col - newCol);
            if (distance < bestDistance) {
              bestDistance = distance;
              bestMove = { row: newRow, col: newCol };
            }
          }
        }
        if (bestMove) {
          badger.row = bestMove.row;
          badger.col = bestMove.col;
        }
        // After moving, if the badger is in the mole's cell that was dug this turn, catch the mole.
        if (
          badger.row === mole.row &&
          badger.col === mole.col &&
          grid[mole.row][mole.col].revealedTime === thisTurn
        ) {
          gameActive = false;
          clearInterval(timerInterval);
          messageEl.textContent = "Game Over: The Badger caught you!";
        }
      }

      // Keydown handler for mole movement.
      function handleKeyDown(e) {
        if (
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)
        ) {
          e.preventDefault();
        }
        if (!gameActive) return;
        let newRow = mole.row;
        let newCol = mole.col;
        if (e.key === "ArrowUp") {
          newRow--;
        } else if (e.key === "ArrowDown") {
          newRow++;
        } else if (e.key === "ArrowLeft") {
          newCol--;
        } else if (e.key === "ArrowRight") {
          newCol++;
        } else {
          return;
        }
        if (newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols)
          return;

        // Increment turn.
        const thisTurn = currentTurn + 1;
        currentTurn = thisTurn;

        // Update mole position.
        mole.row = newRow;
        mole.col = newCol;

        // If the cell isn't revealed, reveal it and mark with this turn.
        if (!grid[newRow][newCol].revealed) {
          grid[newRow][newCol].revealed = true;
          grid[newRow][newCol].revealedTime = thisTurn;
          if (grid[newRow][newCol].type === "treasure") {
            score += 10;
            treasuresLeft--;
            grid[newRow][newCol].type = "dirt";
            if (treasuresLeft === 0) {
              gameActive = false;
              clearInterval(timerInterval);
              messageEl.textContent =
                "Congratulations! Level " + level + " complete!";
              setTimeout(() => {
                level++;
                initGame();
              }, 2000);
            } else {
              messageEl.textContent = "You found an onigiri!";
            }
          }
        }
        moveBadger(thisTurn);
        update();
      }

      // Attach keydown listener only once.
      document.addEventListener("keydown", handleKeyDown);

      newGameBtn.addEventListener("click", () => {
        level = 1;
        initGame();
      });

      initGame();
    </script>
  </body>
</html>
